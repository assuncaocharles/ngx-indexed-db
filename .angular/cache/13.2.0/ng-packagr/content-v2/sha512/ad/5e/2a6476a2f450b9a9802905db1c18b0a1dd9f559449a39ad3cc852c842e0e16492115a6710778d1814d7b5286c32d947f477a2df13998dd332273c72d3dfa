{"hash":"933ebed176ee8d2b698e2ed0c3145e6fa3110854","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            reject('IndexedDB not available');\n        }\n        const request = indexedDB.open(dbName, version);\n        let db;\n        request.onsuccess = (event) => {\n            db = request.result;\n            resolve(db);\n        };\n        request.onerror = (event) => {\n            reject(`IndexedDB error: ${request.error}`);\n        };\n        if (typeof upgradeCallback === 'function') {\n            request.onupgradeneeded = (event) => {\n                upgradeCallback(event, db);\n            };\n        }\n    });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    if (!indexedDB) {\n        return;\n    }\n    const request = indexedDB.open(dbName, version);\n    request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        storeSchemas.forEach((storeSchema) => {\n            if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                storeSchema.storeSchema.forEach((schema) => {\n                    objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                });\n            }\n        });\n        const storeMigrations = migrationFactory && migrationFactory();\n        if (storeMigrations) {\n            Object.keys(storeMigrations)\n                .map((k) => parseInt(k, 10))\n                .filter((v) => v > event.oldVersion)\n                .sort((a, b) => a - b)\n                .forEach((v) => {\n                storeMigrations[v](database, request.transaction);\n            });\n        }\n        database.close();\n    };\n    request.onsuccess = (e) => {\n        e.target.result.close();\n    };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n    if (!dbName || !version || !storeName) {\n        throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n    }\n    return new Observable((obs) => {\n        try {\n            const newVersion = version + 1;\n            const request = indexedDB.open(dbName, newVersion);\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                database.deleteObjectStore(storeName);\n                database.close();\n                console.log('onupgradeneeded');\n                obs.next(true);\n                obs.complete();\n            };\n            request.onerror = (e) => obs.error(e);\n        }\n        catch (error) {\n            obs.error(error);\n        }\n    });\n}\n\nfunction validateStoreName(db, storeName) {\n    return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n    if (!db) {\n        reject('You need to use the openDatabase function to create a database before you query it!');\n    }\n    if (!validateStoreName(db, storeName)) {\n        reject(`objectStore does not exists: ${storeName}`);\n    }\n}\nfunction createTransaction(db, options) {\n    const trans = db.transaction(options.storeName, options.dbMode);\n    trans.onerror = options.error;\n    trans.onabort = options.abort;\n    return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n    return {\n        storeName,\n        dbMode: type,\n        error: (e) => {\n            reject(e);\n        },\n        abort: (e) => {\n            reject(e);\n        },\n    };\n}\n\nvar DBMode;\n(function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n    constructor(dbConfig, platformId) {\n        this.dbConfig = dbConfig;\n        this.platformId = platformId;\n        if (!dbConfig.name) {\n            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        if (this.isBrowser) {\n            this.indexedDB =\n                window.indexedDB ||\n                    window.mozIndexedDB ||\n                    window.webkitIndexedDB ||\n                    window.msIndexedDB;\n            CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n            openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n                if (db.version !== dbConfig.version) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n                        console.warn(`Using latest version ${db.version}`);\n                    }\n                    this.dbConfig.version = db.version;\n                }\n            });\n        }\n    }\n    /**\n     * Allows to crate a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    createObjectStore(storeSchema, migrationFactory) {\n        const storeSchemas = [storeSchema];\n        CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n                request.onsuccess = async (evt) => {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n        const promises = new Promise((resolve, reject) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n                const objectStore = transaction.objectStore(storeName);\n                const results = values.map((value) => {\n                    return new Promise((resolve1, reject1) => {\n                        const key = value.key;\n                        delete value.key;\n                        const request = Boolean(key)\n                            ? objectStore.add(value, key)\n                            : objectStore.add(value);\n                        request.onsuccess = (evt) => {\n                            const result = evt.target.result;\n                            resolve1(result);\n                        };\n                    });\n                });\n                resolve(Promise.all(results));\n            }).catch((reason) => reject(reason));\n        });\n        return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n        const promises = keys.map((key) => {\n            return new Promise((resolve, reject) => {\n                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                    .then((db) => {\n                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n                    const objectStore = transaction.objectStore(storeName);\n                    objectStore.delete(key);\n                    transaction.oncomplete = () => {\n                        this.getAll(storeName)\n                            .pipe(take(1))\n                            .subscribe((newValues) => {\n                            resolve(newValues);\n                        });\n                    };\n                })\n                    .catch((reason) => reject(reason));\n            });\n        });\n        return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n        const observables = keys.map((key) => this.getByKey(storeName, key));\n        return new Observable((obs) => {\n            combineLatest(observables).subscribe((values) => {\n                obs.next(values);\n                obs.complete();\n            });\n        });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(id);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.getAll();\n                request.onerror = (evt) => {\n                    obs.error(evt);\n                };\n                request.onsuccess = ({ target: { result: ResultAll } }) => {\n                    obs.next(ResultAll);\n                    obs.complete();\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns all items from the store after update.\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     * @param key The key of the entry to update if exists\n     */\n    update(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n                key ? objectStore.put(value, key) : objectStore.put(value);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the item you updated from the store after the update.\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     * @param key The key of the entry to update\n     */\n    updateByKey(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    this.getByKey(storeName, key)\n                        .pipe(take(1))\n                        .subscribe((newValue) => {\n                        obs.next(newValue);\n                        obs.complete();\n                    });\n                };\n                objectStore.put(value, key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.delete(key);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                objectStore.delete(key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.clear();\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then(async (db) => {\n                await db.close();\n                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n                deleteDBRequest.onsuccess = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                deleteDBRequest.onerror = (error) => obs.error(error);\n                deleteDBRequest.onblocked = () => {\n                    throw new Error(`Unable to delete database because it's blocked`);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    obs.next(event);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n        const obs = new Subject();\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n            .then((db) => {\n            validateBeforeTransaction(db, storeName, (reason) => {\n                obs.error(reason);\n            });\n            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {\n                obs.error(reason);\n            }, () => {\n                obs.next();\n            }));\n            const objectStore = transaction.objectStore(storeName);\n            const index = objectStore.index(indexName);\n            const request = index.openCursor(keyRange);\n            request.onsuccess = (event) => {\n                obs.next(event);\n            };\n        })\n            .catch((reason) => obs.error(reason));\n        return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push(cursor.value);\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openKeyCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n}\nNgxIndexedDBService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxIndexedDBService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CONFIG_TOKEN]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\n\nclass NgxIndexedDBModule {\n    static forRoot(dbConfig) {\n        return {\n            ngModule: NgxIndexedDBModule,\n            providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n        };\n    }\n}\nNgxIndexedDBModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxIndexedDBModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] });\nNgxIndexedDBModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [],\n                    imports: [CommonModule]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n//# sourceMappingURL=ngx-indexed-db.mjs.map\n","map":{"version":3,"file":"ngx-indexed-db.mjs","sources":["../../../projects/ngx-indexed-db/src/lib/ngx-indexed-db.ts","../../../projects/ngx-indexed-db/src/utils/index.ts","../../../projects/ngx-indexed-db/src/lib/ngx-indexed-db.meta.ts","../../../projects/ngx-indexed-db/src/lib/ngx-indexed-db.service.ts","../../../projects/ngx-indexed-db/src/lib/ngxindexeddb.module.ts","../../../projects/ngx-indexed-db/src/ngx-indexed-db.ts"],"sourcesContent":["import { ObjectStoreMeta, ObjectStoreSchema } from './ngx-indexed-db.meta';\nimport { Observable, Subscriber } from 'rxjs';\n\nexport function openDatabase(\n  indexedDB: IDBFactory,\n  dbName: string,\n  version?: number,\n  upgradeCallback?: (a: Event, b: IDBDatabase) => void\n): Promise<IDBDatabase> {\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n    const request = indexedDB.open(dbName, version);\n    let db: IDBDatabase;\n    request.onsuccess = (event: Event) => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = (event: Event) => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = (event: Event) => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nexport function CreateObjectStore(\n  indexedDB: IDBFactory,\n  dbName: string,\n  version: number,\n  storeSchemas: ObjectStoreMeta[],\n  migrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void }\n): void {\n  if (!indexedDB) {\n    return;\n  }\n  const request: IDBOpenDBRequest = indexedDB.open(dbName, version);\n\n  request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n    const database: IDBDatabase = (event.target as any).result;\n\n    storeSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n\n    const storeMigrations = migrationFactory && migrationFactory();\n    if (storeMigrations) {\n      Object.keys(storeMigrations)\n        .map((k) => parseInt(k, 10))\n        .filter((v) => v > event.oldVersion)\n        .sort((a, b) => a - b)\n        .forEach((v) => {\n          storeMigrations[v](database, request.transaction);\n        });\n    }\n\n    database.close();\n  };\n\n  request.onsuccess = (e: any) => {\n    e.target.result.close();\n  };\n}\n\nexport function DeleteObjectStore(dbName: string, version: number, storeName: string): Observable<boolean> {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n\n  return new Observable<boolean>((obs: Subscriber<boolean>) => {\n    try {\n      const newVersion = version + 1;\n      const request: IDBOpenDBRequest = indexedDB.open(dbName, newVersion);\n      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n        const database: IDBDatabase = (event.target as any).result;\n\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n\n      request.onerror = (e) => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n\n\n}\n","export interface Options {\n  storeName: string;\n  dbMode: IDBTransactionMode;\n  error: (e: Event) => any;\n  complete?: (e: Event) => any;\n  abort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string): boolean {\n  return db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: (message: string) => void): void {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nexport function createTransaction(db: IDBDatabase, options: Options): IDBTransaction {\n  const trans: IDBTransaction = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nexport function optionsGenerator(\n  type: any,\n  storeName: any,\n  reject: (reason?: any) => void,\n  resolve?: (e: any) => void\n): Options {\n  return {\n    storeName,\n    dbMode: type,\n    error: (e: Event) => {\n      reject(e);\n    },\n    abort: (e: Event) => {\n      reject(e);\n    },\n  };\n}\n","import { InjectionToken } from '@angular/core';\n\nexport interface DBConfig {\n  name: string;\n  version: number;\n  objectStoresMeta: ObjectStoreMeta[];\n  migrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void };\n}\n\nexport interface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string | string[]; autoIncrement: boolean; [key: string]: any };\n  storeSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n  name: string;\n  keypath: string | string[];\n  options: { unique: boolean; [key: string]: any };\n}\n\nexport interface IndexDetails {\n  indexName: string;\n  order: string;\n}\n\nexport interface RequestEvent<T> extends Event {\n  target: RequestEventTarget<T>;\n}\n\nexport interface RequestEventTarget<T> extends EventTarget {\n  result: T | T[];\n}\n\nexport enum DBMode {\n  readonly = 'readonly',\n  readwrite = 'readwrite',\n}\n\nexport type Key = string | number | Date | ArrayBufferView | ArrayBuffer | IDBValidKey | IDBKeyRange;\n\nexport type WithID = {id: number};\n\nexport const CONFIG_TOKEN = new InjectionToken<DBConfig>(null);\n","import { Injectable, Inject, PLATFORM_ID } from '@angular/core';\nimport { openDatabase, CreateObjectStore, DeleteObjectStore } from './ngx-indexed-db';\nimport { createTransaction, optionsGenerator, validateBeforeTransaction } from '../utils';\nimport { CONFIG_TOKEN, DBConfig, Key, RequestEvent, ObjectStoreMeta, DBMode, WithID } from './ngx-indexed-db.meta';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Observable, Subject, combineLatest, from } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\n@Injectable()\nexport class NgxIndexedDBService {\n  private readonly isBrowser: boolean;\n  private indexedDB: IDBFactory;\n\n  constructor(@Inject(CONFIG_TOKEN) private dbConfig: DBConfig, @Inject(PLATFORM_ID) private platformId: any) {\n    if (!dbConfig.name) {\n      throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n    }\n    if (!dbConfig.version) {\n      throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n    }\n    this.isBrowser = isPlatformBrowser(this.platformId);\n    if (this.isBrowser) {\n      this.indexedDB =\n        window.indexedDB ||\n        (window as any).mozIndexedDB ||\n        (window as any).webkitIndexedDB ||\n        (window as any).msIndexedDB;\n\n      CreateObjectStore(\n        this.indexedDB,\n        dbConfig.name,\n        dbConfig.version,\n        dbConfig.objectStoresMeta,\n        dbConfig.migrationFactory\n      );\n\n      openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n        if (db.version !== dbConfig.version) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n            console.warn(`Using latest version ${db.version}`);\n          }\n          this.dbConfig.version = db.version;\n        }\n      });\n    }\n  }\n\n  /**\n   * Allows to crate a new object store ad-hoc\n   * @param storeName The name of the store to be created\n   * @param migrationFactory The migration factory if exists\n   */\n  createObjectStore(\n    storeSchema: ObjectStoreMeta,\n    migrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void }\n  ): void {\n    const storeSchemas: ObjectStoreMeta[] = [storeSchema];\n    CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n  }\n\n  /**\n   * Adds new entry in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param value The entry to be added\n   * @param key The optional key for the entry\n   */\n  add<T>(storeName: string, value: T, key?: any): Observable<T & WithID> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request: IDBRequest<IDBValidKey> = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n\n          request.onsuccess = async (evt: Event) => {\n            const result: any = (evt.target as IDBOpenDBRequest).result;\n            const getRequest: IDBRequest = objectStore.get(result) as IDBRequest<T>;\n            getRequest.onsuccess = (event: Event) => {\n              obs.next((event.target as IDBRequest<T & WithID>).result);\n              obs.complete();\n            };\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Adds new entries in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param values The entries to be added containing optional key attribute\n   */\n  bulkAdd<T>(storeName: string, values: Array<T & { key?: any }>): Observable<number[]> {\n    const promises = new Promise<number[]>((resolve, reject) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n          const objectStore = transaction.objectStore(storeName);\n\n          const results = values.map((value) => {\n            return new Promise<number>((resolve1, reject1) => {\n              const key = value.key;\n              delete value.key;\n\n              const request: IDBRequest<IDBValidKey> = Boolean(key)\n                ? objectStore.add(value, key)\n                : objectStore.add(value);\n\n              request.onsuccess = (evt: Event) => {\n                const result = (evt.target as IDBOpenDBRequest).result;\n                resolve1((result as unknown) as number);\n              };\n            });\n          });\n\n          resolve(Promise.all(results));\n\n        }).catch((reason) => reject(reason));\n    });\n\n    return from(promises);\n  }\n\n  /**\n   * Delete entries in the store and returns current entries in the store\n   * @param storeName The name of the store to add the item\n   * @param keys The keys to be deleted\n   */\n  bulkDelete(storeName: string, keys: Key[]): Observable<number[]> {\n    const promises = keys.map((key) => {\n      return new Promise<number>((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n          .then((db: IDBDatabase) => {\n            const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n            const objectStore = transaction.objectStore(storeName);\n            objectStore.delete(key);\n\n            transaction.oncomplete = () => {\n              this.getAll(storeName)\n                .pipe(take(1))\n                .subscribe((newValues) => {\n                  resolve(newValues as any);\n                });\n            };\n          })\n          .catch((reason) => reject(reason));\n      });\n    });\n    return from(Promise.all(promises));\n  }\n\n  /**\n   * Returns entry by key.\n   * @param storeName The name of the store to query\n   * @param key The entry key\n   */\n  getByKey<T>(storeName: string, key: IDBValidKey): Observable<T> {\n    return new Observable<T>((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.get(key) as IDBRequest<T>;\n          request.onsuccess = (event: Event) => {\n            obs.next((event.target as IDBRequest<T>).result);\n            obs.complete();\n          };\n          request.onerror = (event: Event) => {\n            obs.error(event);\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Retrieve multiple entries in the store\n   * @param storeName The name of the store to retrieve the items\n   * @param keys The ids entries to be retrieve\n   */\n  bulkGet<T>(storeName: string, keys: Array<IDBValidKey>): any {\n    const observables = keys.map((key) => this.getByKey(storeName, key));\n\n    return new Observable((obs) => {\n      combineLatest(observables).subscribe((values) => {\n        obs.next(values);\n        obs.complete();\n      });\n    });\n  }\n\n  /**\n   * Returns entry by id.\n   * @param storeName The name of the store to query\n   * @param id The entry id\n   */\n  getByID<T>(storeName: string, id: string | number): Observable<T> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n          const request: IDBRequest = objectStore.get(id) as IDBRequest<T>;\n          request.onsuccess = (event: Event) => {\n            obs.next((event.target as IDBRequest<T>).result);\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Returns entry by index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param key The entry key.\n   */\n  getByIndex<T>(storeName: string, indexName: string, key: IDBValidKey): Observable<T> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.get(key) as IDBRequest<T>;\n          request.onsuccess = (event: Event) => {\n            obs.next((event.target as IDBRequest<T>).result);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Return all elements from one store\n   * @param storeName The name of the store to select the items\n   */\n  getAll<T>(storeName: string): Observable<T[]> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n\n          const request: IDBRequest = objectStore.getAll();\n\n          request.onerror = (evt: Event) => {\n            obs.error(evt);\n          };\n\n          request.onsuccess = ({ target: { result: ResultAll } }: RequestEvent<T>) => {\n            obs.next(ResultAll as T[]);\n            obs.complete();\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Returns all items from the store after update.\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   * @param key The key of the entry to update if exists\n   */\n  update<T>(storeName: string, value: T, key?: any): Observable<T[]> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            this.getAll(storeName)\n              .pipe(take(1))\n              .subscribe((newValues) => {\n                obs.next(newValues as T[]);\n                obs.complete();\n              });\n          };\n\n          key ? objectStore.put(value, key) : objectStore.put(value);\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns the item you updated from the store after the update.\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   * @param key The key of the entry to update\n   */\n  updateByKey<T>(storeName: string, value: T, key: IDBValidKey): Observable<T> {\n    return new Observable<T>((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            this.getByKey(storeName, key)\n              .pipe(take(1))\n              .subscribe((newValue) => {\n                obs.next(newValue as T);\n                obs.complete();\n              });\n          };\n\n          objectStore.put(value, key);\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns all items from the store after delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  delete<T>(storeName: string, key: Key): Observable<T[]> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n\n          transaction.oncomplete = () => {\n            this.getAll(storeName)\n              .pipe(take(1))\n              .subscribe((newValues) => {\n                obs.next(newValues as T[]);\n                obs.complete();\n              });\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns true from the store after a successful delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  deleteByKey(storeName: string, key: Key): Observable<boolean> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n\n          objectStore.delete(key);\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns true if successfully delete all entries from the store.\n   * @param storeName The name of the store to have the entries deleted\n   */\n  clear(storeName: string): Observable<boolean> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.clear();\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns true if successfully delete the DB.\n   */\n  deleteDatabase(): Observable<boolean> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then(async (db) => {\n          await db.close();\n          const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n          deleteDBRequest.onsuccess = () => {\n            obs.next(true);\n            obs.complete();\n          };\n          deleteDBRequest.onerror = (error) => obs.error(error);\n          deleteDBRequest.onblocked = () => {\n            throw new Error(`Unable to delete database because it's blocked`);\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Returns the open cursor event\n   * @param storeName The name of the store to have the entries deleted\n   * @param keyRange The key range which the cursor should be open on\n   */\n  openCursor(storeName: string, keyRange?: IDBKeyRange): Observable<Event> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n\n          request.onsuccess = (event: Event) => {\n            obs.next(event);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Open a cursor by index filter.\n   * @param storeName The name of the store to query.\n   * @param indexName The index name to filter.\n   * @param keyRange The range value and criteria to apply on the index.\n   */\n  openCursorByIndex(\n    storeName: string,\n    indexName: string,\n    keyRange: IDBKeyRange,\n    mode: DBMode = DBMode.readonly\n  ): Observable<Event> {\n    const obs = new Subject<Event>();\n\n    openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n      .then((db) => {\n        validateBeforeTransaction(db, storeName, (reason) => {\n          obs.error(reason);\n        });\n        const transaction = createTransaction(\n          db,\n          optionsGenerator(\n            mode,\n            storeName,\n            (reason) => {\n              obs.error(reason);\n            },\n            () => {\n              obs.next();\n            }\n          )\n        );\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n\n        request.onsuccess = (event: Event) => {\n          obs.next(event);\n        };\n      })\n      .catch((reason) => obs.error(reason));\n\n    return obs;\n  }\n\n  /**\n   * Returns all items by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllByIndex<T>(storeName: string, indexName: string, keyRange: IDBKeyRange): Observable<T[]> {\n    const data: T[] = [];\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openCursor(keyRange);\n          request.onsuccess = (event) => {\n            const cursor: IDBCursorWithValue = (event.target as IDBRequest<IDBCursorWithValue>).result;\n            if (cursor) {\n              data.push(cursor.value);\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns all primary keys by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllKeysByIndex(\n    storeName: string,\n    indexName: string,\n    keyRange: IDBKeyRange\n  ): Observable<{ primaryKey: any; key: any }[]> {\n    const data: { primaryKey: any; key: any }[] = [];\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openKeyCursor(keyRange);\n          request.onsuccess = (event) => {\n            const cursor: IDBCursor = (event.target as IDBRequest<IDBCursor>).result;\n            if (cursor) {\n              data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  count(storeName: string, keyRange?: IDBValidKey | IDBKeyRange): Observable<number> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request: IDBRequest = objectStore.count(keyRange);\n          request.onerror = (e) => obs.error(e);\n          request.onsuccess = (e) => {\n            obs.next(((e.target as IDBOpenDBRequest).result as unknown) as number);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Delete the store by name.\n   * @param storeName The name of the store to query\n   */\n  deleteObjectStore(storeName: string): Observable<boolean> {\n      return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n  }\n}\n","import { NgModule, ModuleWithProviders, InjectionToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxIndexedDBService } from './ngx-indexed-db.service';\nimport { DBConfig, CONFIG_TOKEN } from './ngx-indexed-db.meta';\n\n@NgModule({\n  declarations: [],\n  imports: [CommonModule]\n})\nexport class NgxIndexedDBModule {\n  static forRoot(dbConfig: DBConfig): ModuleWithProviders<NgxIndexedDBModule> {\n    return {\n      ngModule: NgxIndexedDBModule,\n      providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { __awaiter } from 'tslib';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            reject('IndexedDB not available');\n        }\n        const request = indexedDB.open(dbName, version);\n        let db;\n        request.onsuccess = (event) => {\n            db = request.result;\n            resolve(db);\n        };\n        request.onerror = (event) => {\n            reject(`IndexedDB error: ${request.error}`);\n        };\n        if (typeof upgradeCallback === 'function') {\n            request.onupgradeneeded = (event) => {\n                upgradeCallback(event, db);\n            };\n        }\n    });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    if (!indexedDB) {\n        return;\n    }\n    const request = indexedDB.open(dbName, version);\n    request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        storeSchemas.forEach((storeSchema) => {\n            if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                storeSchema.storeSchema.forEach((schema) => {\n                    objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                });\n            }\n        });\n        const storeMigrations = migrationFactory && migrationFactory();\n        if (storeMigrations) {\n            Object.keys(storeMigrations)\n                .map((k) => parseInt(k, 10))\n                .filter((v) => v > event.oldVersion)\n                .sort((a, b) => a - b)\n                .forEach((v) => {\n                storeMigrations[v](database, request.transaction);\n            });\n        }\n        database.close();\n    };\n    request.onsuccess = (e) => {\n        e.target.result.close();\n    };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n    if (!dbName || !version || !storeName) {\n        throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n    }\n    return new Observable((obs) => {\n        try {\n            const newVersion = version + 1;\n            const request = indexedDB.open(dbName, newVersion);\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                database.deleteObjectStore(storeName);\n                database.close();\n                console.log('onupgradeneeded');\n                obs.next(true);\n                obs.complete();\n            };\n            request.onerror = (e) => obs.error(e);\n        }\n        catch (error) {\n            obs.error(error);\n        }\n    });\n}\n\nfunction validateStoreName(db, storeName) {\n    return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n    if (!db) {\n        reject('You need to use the openDatabase function to create a database before you query it!');\n    }\n    if (!validateStoreName(db, storeName)) {\n        reject(`objectStore does not exists: ${storeName}`);\n    }\n}\nfunction createTransaction(db, options) {\n    const trans = db.transaction(options.storeName, options.dbMode);\n    trans.onerror = options.error;\n    trans.onabort = options.abort;\n    return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n    return {\n        storeName,\n        dbMode: type,\n        error: (e) => {\n            reject(e);\n        },\n        abort: (e) => {\n            reject(e);\n        },\n    };\n}\n\nvar DBMode;\n(function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n    constructor(dbConfig, platformId) {\n        this.dbConfig = dbConfig;\n        this.platformId = platformId;\n        if (!dbConfig.name) {\n            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        if (this.isBrowser) {\n            this.indexedDB =\n                window.indexedDB ||\n                    window.mozIndexedDB ||\n                    window.webkitIndexedDB ||\n                    window.msIndexedDB;\n            CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n            openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n                if (db.version !== dbConfig.version) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n                        console.warn(`Using latest version ${db.version}`);\n                    }\n                    this.dbConfig.version = db.version;\n                }\n            });\n        }\n    }\n    /**\n     * Allows to crate a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    createObjectStore(storeSchema, migrationFactory) {\n        const storeSchemas = [storeSchema];\n        CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n                request.onsuccess = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                });\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n        const promises = new Promise((resolve, reject) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n                const objectStore = transaction.objectStore(storeName);\n                const results = values.map((value) => {\n                    return new Promise((resolve1, reject1) => {\n                        const key = value.key;\n                        delete value.key;\n                        const request = Boolean(key)\n                            ? objectStore.add(value, key)\n                            : objectStore.add(value);\n                        request.onsuccess = (evt) => {\n                            const result = evt.target.result;\n                            resolve1(result);\n                        };\n                    });\n                });\n                resolve(Promise.all(results));\n            }).catch((reason) => reject(reason));\n        });\n        return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n        const promises = keys.map((key) => {\n            return new Promise((resolve, reject) => {\n                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                    .then((db) => {\n                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n                    const objectStore = transaction.objectStore(storeName);\n                    objectStore.delete(key);\n                    transaction.oncomplete = () => {\n                        this.getAll(storeName)\n                            .pipe(take(1))\n                            .subscribe((newValues) => {\n                            resolve(newValues);\n                        });\n                    };\n                })\n                    .catch((reason) => reject(reason));\n            });\n        });\n        return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n        const observables = keys.map((key) => this.getByKey(storeName, key));\n        return new Observable((obs) => {\n            combineLatest(observables).subscribe((values) => {\n                obs.next(values);\n                obs.complete();\n            });\n        });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(id);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.getAll();\n                request.onerror = (evt) => {\n                    obs.error(evt);\n                };\n                request.onsuccess = ({ target: { result: ResultAll } }) => {\n                    obs.next(ResultAll);\n                    obs.complete();\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns all items from the store after update.\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     * @param key The key of the entry to update if exists\n     */\n    update(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n                key ? objectStore.put(value, key) : objectStore.put(value);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the item you updated from the store after the update.\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     * @param key The key of the entry to update\n     */\n    updateByKey(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    this.getByKey(storeName, key)\n                        .pipe(take(1))\n                        .subscribe((newValue) => {\n                        obs.next(newValue);\n                        obs.complete();\n                    });\n                };\n                objectStore.put(value, key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.delete(key);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                objectStore.delete(key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.clear();\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => __awaiter(this, void 0, void 0, function* () {\n                yield db.close();\n                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n                deleteDBRequest.onsuccess = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                deleteDBRequest.onerror = (error) => obs.error(error);\n                deleteDBRequest.onblocked = () => {\n                    throw new Error(`Unable to delete database because it's blocked`);\n                };\n            }))\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    obs.next(event);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n        const obs = new Subject();\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n            .then((db) => {\n            validateBeforeTransaction(db, storeName, (reason) => {\n                obs.error(reason);\n            });\n            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {\n                obs.error(reason);\n            }, () => {\n                obs.next();\n            }));\n            const objectStore = transaction.objectStore(storeName);\n            const index = objectStore.index(indexName);\n            const request = index.openCursor(keyRange);\n            request.onsuccess = (event) => {\n                obs.next(event);\n            };\n        })\n            .catch((reason) => obs.error(reason));\n        return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push(cursor.value);\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openKeyCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, obs.error);\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n}\nNgxIndexedDBService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxIndexedDBService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [CONFIG_TOKEN]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }];\n    } });\n\nclass NgxIndexedDBModule {\n    static forRoot(dbConfig) {\n        return {\n            ngModule: NgxIndexedDBModule,\n            providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n        };\n    }\n}\nNgxIndexedDBModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxIndexedDBModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] });\nNgxIndexedDBModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.0\", ngImport: i0, type: NgxIndexedDBModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [],\n                    imports: [CommonModule]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n//# sourceMappingURL=ngx-indexed-db.mjs.map\n","map":{"version":3,"file":"ngx-indexed-db.mjs","sources":["../../../projects/ngx-indexed-db/src/lib/ngx-indexed-db.ts","../../../projects/ngx-indexed-db/src/utils/index.ts","../../../projects/ngx-indexed-db/src/lib/ngx-indexed-db.meta.ts","../../../projects/ngx-indexed-db/src/lib/ngx-indexed-db.service.ts","../../../projects/ngx-indexed-db/src/lib/ngxindexeddb.module.ts","../../../projects/ngx-indexed-db/src/ngx-indexed-db.ts"],"sourcesContent":["import { ObjectStoreMeta, ObjectStoreSchema } from './ngx-indexed-db.meta';\nimport { Observable, Subscriber } from 'rxjs';\n\nexport function openDatabase(\n  indexedDB: IDBFactory,\n  dbName: string,\n  version?: number,\n  upgradeCallback?: (a: Event, b: IDBDatabase) => void\n): Promise<IDBDatabase> {\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n    const request = indexedDB.open(dbName, version);\n    let db: IDBDatabase;\n    request.onsuccess = (event: Event) => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = (event: Event) => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = (event: Event) => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nexport function CreateObjectStore(\n  indexedDB: IDBFactory,\n  dbName: string,\n  version: number,\n  storeSchemas: ObjectStoreMeta[],\n  migrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void }\n): void {\n  if (!indexedDB) {\n    return;\n  }\n  const request: IDBOpenDBRequest = indexedDB.open(dbName, version);\n\n  request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n    const database: IDBDatabase = (event.target as any).result;\n\n    storeSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n\n    const storeMigrations = migrationFactory && migrationFactory();\n    if (storeMigrations) {\n      Object.keys(storeMigrations)\n        .map((k) => parseInt(k, 10))\n        .filter((v) => v > event.oldVersion)\n        .sort((a, b) => a - b)\n        .forEach((v) => {\n          storeMigrations[v](database, request.transaction);\n        });\n    }\n\n    database.close();\n  };\n\n  request.onsuccess = (e: any) => {\n    e.target.result.close();\n  };\n}\n\nexport function DeleteObjectStore(dbName: string, version: number, storeName: string): Observable<boolean> {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n\n  return new Observable<boolean>((obs: Subscriber<boolean>) => {\n    try {\n      const newVersion = version + 1;\n      const request: IDBOpenDBRequest = indexedDB.open(dbName, newVersion);\n      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n        const database: IDBDatabase = (event.target as any).result;\n\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n\n      request.onerror = (e) => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n\n\n}\n","export interface Options {\n  storeName: string;\n  dbMode: IDBTransactionMode;\n  error: (e: Event) => any;\n  complete?: (e: Event) => any;\n  abort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string): boolean {\n  return db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: (message: string) => void): void {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nexport function createTransaction(db: IDBDatabase, options: Options): IDBTransaction {\n  const trans: IDBTransaction = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nexport function optionsGenerator(\n  type: any,\n  storeName: any,\n  reject: (reason?: any) => void,\n  resolve?: (e: any) => void\n): Options {\n  return {\n    storeName,\n    dbMode: type,\n    error: (e: Event) => {\n      reject(e);\n    },\n    abort: (e: Event) => {\n      reject(e);\n    },\n  };\n}\n","import { InjectionToken } from '@angular/core';\n\nexport interface DBConfig {\n  name: string;\n  version: number;\n  objectStoresMeta: ObjectStoreMeta[];\n  migrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void };\n}\n\nexport interface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string | string[]; autoIncrement: boolean; [key: string]: any };\n  storeSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n  name: string;\n  keypath: string | string[];\n  options: { unique: boolean; [key: string]: any };\n}\n\nexport interface IndexDetails {\n  indexName: string;\n  order: string;\n}\n\nexport interface RequestEvent<T> extends Event {\n  target: RequestEventTarget<T>;\n}\n\nexport interface RequestEventTarget<T> extends EventTarget {\n  result: T | T[];\n}\n\nexport enum DBMode {\n  readonly = 'readonly',\n  readwrite = 'readwrite',\n}\n\nexport type Key = string | number | Date | ArrayBufferView | ArrayBuffer | IDBValidKey | IDBKeyRange;\n\nexport type WithID = {id: number};\n\nexport const CONFIG_TOKEN = new InjectionToken<DBConfig>(null);\n","import { Injectable, Inject, PLATFORM_ID } from '@angular/core';\nimport { openDatabase, CreateObjectStore, DeleteObjectStore } from './ngx-indexed-db';\nimport { createTransaction, optionsGenerator, validateBeforeTransaction } from '../utils';\nimport { CONFIG_TOKEN, DBConfig, Key, RequestEvent, ObjectStoreMeta, DBMode, WithID } from './ngx-indexed-db.meta';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Observable, Subject, combineLatest, from } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\n@Injectable()\nexport class NgxIndexedDBService {\n  private readonly isBrowser: boolean;\n  private indexedDB: IDBFactory;\n\n  constructor(@Inject(CONFIG_TOKEN) private dbConfig: DBConfig, @Inject(PLATFORM_ID) private platformId: any) {\n    if (!dbConfig.name) {\n      throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n    }\n    if (!dbConfig.version) {\n      throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n    }\n    this.isBrowser = isPlatformBrowser(this.platformId);\n    if (this.isBrowser) {\n      this.indexedDB =\n        window.indexedDB ||\n        (window as any).mozIndexedDB ||\n        (window as any).webkitIndexedDB ||\n        (window as any).msIndexedDB;\n\n      CreateObjectStore(\n        this.indexedDB,\n        dbConfig.name,\n        dbConfig.version,\n        dbConfig.objectStoresMeta,\n        dbConfig.migrationFactory\n      );\n\n      openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n        if (db.version !== dbConfig.version) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${this.dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n            console.warn(`Using latest version ${db.version}`);\n          }\n          this.dbConfig.version = db.version;\n        }\n      });\n    }\n  }\n\n  /**\n   * Allows to crate a new object store ad-hoc\n   * @param storeName The name of the store to be created\n   * @param migrationFactory The migration factory if exists\n   */\n  createObjectStore(\n    storeSchema: ObjectStoreMeta,\n    migrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void }\n  ): void {\n    const storeSchemas: ObjectStoreMeta[] = [storeSchema];\n    CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n  }\n\n  /**\n   * Adds new entry in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param value The entry to be added\n   * @param key The optional key for the entry\n   */\n  add<T>(storeName: string, value: T, key?: any): Observable<T & WithID> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request: IDBRequest<IDBValidKey> = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n\n          request.onsuccess = async (evt: Event) => {\n            const result: any = (evt.target as IDBOpenDBRequest).result;\n            const getRequest: IDBRequest = objectStore.get(result) as IDBRequest<T>;\n            getRequest.onsuccess = (event: Event) => {\n              obs.next((event.target as IDBRequest<T & WithID>).result);\n              obs.complete();\n            };\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Adds new entries in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param values The entries to be added containing optional key attribute\n   */\n  bulkAdd<T>(storeName: string, values: Array<T & { key?: any }>): Observable<number[]> {\n    const promises = new Promise<number[]>((resolve, reject) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n          const objectStore = transaction.objectStore(storeName);\n\n          const results = values.map((value) => {\n            return new Promise<number>((resolve1, reject1) => {\n              const key = value.key;\n              delete value.key;\n\n              const request: IDBRequest<IDBValidKey> = Boolean(key)\n                ? objectStore.add(value, key)\n                : objectStore.add(value);\n\n              request.onsuccess = (evt: Event) => {\n                const result = (evt.target as IDBOpenDBRequest).result;\n                resolve1((result as unknown) as number);\n              };\n            });\n          });\n\n          resolve(Promise.all(results));\n\n        }).catch((reason) => reject(reason));\n    });\n\n    return from(promises);\n  }\n\n  /**\n   * Delete entries in the store and returns current entries in the store\n   * @param storeName The name of the store to add the item\n   * @param keys The keys to be deleted\n   */\n  bulkDelete(storeName: string, keys: Key[]): Observable<number[]> {\n    const promises = keys.map((key) => {\n      return new Promise<number>((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n          .then((db: IDBDatabase) => {\n            const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n            const objectStore = transaction.objectStore(storeName);\n            objectStore.delete(key);\n\n            transaction.oncomplete = () => {\n              this.getAll(storeName)\n                .pipe(take(1))\n                .subscribe((newValues) => {\n                  resolve(newValues as any);\n                });\n            };\n          })\n          .catch((reason) => reject(reason));\n      });\n    });\n    return from(Promise.all(promises));\n  }\n\n  /**\n   * Returns entry by key.\n   * @param storeName The name of the store to query\n   * @param key The entry key\n   */\n  getByKey<T>(storeName: string, key: IDBValidKey): Observable<T> {\n    return new Observable<T>((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = objectStore.get(key) as IDBRequest<T>;\n          request.onsuccess = (event: Event) => {\n            obs.next((event.target as IDBRequest<T>).result);\n            obs.complete();\n          };\n          request.onerror = (event: Event) => {\n            obs.error(event);\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Retrieve multiple entries in the store\n   * @param storeName The name of the store to retrieve the items\n   * @param keys The ids entries to be retrieve\n   */\n  bulkGet<T>(storeName: string, keys: Array<IDBValidKey>): any {\n    const observables = keys.map((key) => this.getByKey(storeName, key));\n\n    return new Observable((obs) => {\n      combineLatest(observables).subscribe((values) => {\n        obs.next(values);\n        obs.complete();\n      });\n    });\n  }\n\n  /**\n   * Returns entry by id.\n   * @param storeName The name of the store to query\n   * @param id The entry id\n   */\n  getByID<T>(storeName: string, id: string | number): Observable<T> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db: IDBDatabase) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n          const request: IDBRequest = objectStore.get(id) as IDBRequest<T>;\n          request.onsuccess = (event: Event) => {\n            obs.next((event.target as IDBRequest<T>).result);\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Returns entry by index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param key The entry key.\n   */\n  getByIndex<T>(storeName: string, indexName: string, key: IDBValidKey): Observable<T> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.get(key) as IDBRequest<T>;\n          request.onsuccess = (event: Event) => {\n            obs.next((event.target as IDBRequest<T>).result);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Return all elements from one store\n   * @param storeName The name of the store to select the items\n   */\n  getAll<T>(storeName: string): Observable<T[]> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n          const objectStore = transaction.objectStore(storeName);\n\n          const request: IDBRequest = objectStore.getAll();\n\n          request.onerror = (evt: Event) => {\n            obs.error(evt);\n          };\n\n          request.onsuccess = ({ target: { result: ResultAll } }: RequestEvent<T>) => {\n            obs.next(ResultAll as T[]);\n            obs.complete();\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Returns all items from the store after update.\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   * @param key The key of the entry to update if exists\n   */\n  update<T>(storeName: string, value: T, key?: any): Observable<T[]> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            this.getAll(storeName)\n              .pipe(take(1))\n              .subscribe((newValues) => {\n                obs.next(newValues as T[]);\n                obs.complete();\n              });\n          };\n\n          key ? objectStore.put(value, key) : objectStore.put(value);\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns the item you updated from the store after the update.\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   * @param key The key of the entry to update\n   */\n  updateByKey<T>(storeName: string, value: T, key: IDBValidKey): Observable<T> {\n    return new Observable<T>((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            this.getByKey(storeName, key)\n              .pipe(take(1))\n              .subscribe((newValue) => {\n                obs.next(newValue as T);\n                obs.complete();\n              });\n          };\n\n          objectStore.put(value, key);\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns all items from the store after delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  delete<T>(storeName: string, key: Key): Observable<T[]> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n\n          transaction.oncomplete = () => {\n            this.getAll(storeName)\n              .pipe(take(1))\n              .subscribe((newValues) => {\n                obs.next(newValues as T[]);\n                obs.complete();\n              });\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns true from the store after a successful delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  deleteByKey(storeName: string, key: Key): Observable<boolean> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n\n          objectStore.delete(key);\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns true if successfully delete all entries from the store.\n   * @param storeName The name of the store to have the entries deleted\n   */\n  clear(storeName: string): Observable<boolean> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.clear();\n          transaction.oncomplete = () => {\n            obs.next(true);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns true if successfully delete the DB.\n   */\n  deleteDatabase(): Observable<boolean> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then(async (db) => {\n          await db.close();\n          const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n          deleteDBRequest.onsuccess = () => {\n            obs.next(true);\n            obs.complete();\n          };\n          deleteDBRequest.onerror = (error) => obs.error(error);\n          deleteDBRequest.onblocked = () => {\n            throw new Error(`Unable to delete database because it's blocked`);\n          };\n        })\n        .catch((error) => obs.error(error));\n    });\n  }\n\n  /**\n   * Returns the open cursor event\n   * @param storeName The name of the store to have the entries deleted\n   * @param keyRange The key range which the cursor should be open on\n   */\n  openCursor(storeName: string, keyRange?: IDBKeyRange): Observable<Event> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n\n          request.onsuccess = (event: Event) => {\n            obs.next(event);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Open a cursor by index filter.\n   * @param storeName The name of the store to query.\n   * @param indexName The index name to filter.\n   * @param keyRange The range value and criteria to apply on the index.\n   */\n  openCursorByIndex(\n    storeName: string,\n    indexName: string,\n    keyRange: IDBKeyRange,\n    mode: DBMode = DBMode.readonly\n  ): Observable<Event> {\n    const obs = new Subject<Event>();\n\n    openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n      .then((db) => {\n        validateBeforeTransaction(db, storeName, (reason) => {\n          obs.error(reason);\n        });\n        const transaction = createTransaction(\n          db,\n          optionsGenerator(\n            mode,\n            storeName,\n            (reason) => {\n              obs.error(reason);\n            },\n            () => {\n              obs.next();\n            }\n          )\n        );\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n\n        request.onsuccess = (event: Event) => {\n          obs.next(event);\n        };\n      })\n      .catch((reason) => obs.error(reason));\n\n    return obs;\n  }\n\n  /**\n   * Returns all items by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllByIndex<T>(storeName: string, indexName: string, keyRange: IDBKeyRange): Observable<T[]> {\n    const data: T[] = [];\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openCursor(keyRange);\n          request.onsuccess = (event) => {\n            const cursor: IDBCursorWithValue = (event.target as IDBRequest<IDBCursorWithValue>).result;\n            if (cursor) {\n              data.push(cursor.value);\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns all primary keys by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllKeysByIndex(\n    storeName: string,\n    indexName: string,\n    keyRange: IDBKeyRange\n  ): Observable<{ primaryKey: any; key: any }[]> {\n    const data: { primaryKey: any; key: any }[] = [];\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const index = objectStore.index(indexName);\n          const request = index.openKeyCursor(keyRange);\n          request.onsuccess = (event) => {\n            const cursor: IDBCursor = (event.target as IDBRequest<IDBCursor>).result;\n            if (cursor) {\n              data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n              cursor.continue();\n            } else {\n              obs.next(data);\n              obs.complete();\n            }\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  count(storeName: string, keyRange?: IDBValidKey | IDBKeyRange): Observable<number> {\n    return new Observable((obs) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n        .then((db) => {\n          validateBeforeTransaction(db, storeName, obs.error);\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n          const objectStore = transaction.objectStore(storeName);\n          const request: IDBRequest = objectStore.count(keyRange);\n          request.onerror = (e) => obs.error(e);\n          request.onsuccess = (e) => {\n            obs.next(((e.target as IDBOpenDBRequest).result as unknown) as number);\n            obs.complete();\n          };\n        })\n        .catch((reason) => obs.error(reason));\n    });\n  }\n\n  /**\n   * Delete the store by name.\n   * @param storeName The name of the store to query\n   */\n  deleteObjectStore(storeName: string): Observable<boolean> {\n      return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n  }\n}\n","import { NgModule, ModuleWithProviders, InjectionToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxIndexedDBService } from './ngx-indexed-db.service';\nimport { DBConfig, CONFIG_TOKEN } from './ngx-indexed-db.meta';\n\n@NgModule({\n  declarations: [],\n  imports: [CommonModule]\n})\nexport class NgxIndexedDBModule {\n  static forRoot(dbConfig: DBConfig): ModuleWithProviders<NgxIndexedDBModule> {\n    return {\n      ngModule: NgxIndexedDBModule,\n      providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}}}